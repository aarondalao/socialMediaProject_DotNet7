signalR steps
1) set up and configure migrations
	a) in domain solution, create new class called Comment. create properties namely Id which is an int, 
    body with a string data type, Author with an AppUser model type, Activity with an Activity Type,
    CreatedAt property with a DateTime type and with a value of UtcNow. 
    b) add a relationship between the newly created model/entity Comment with the Activity model/entity
        * to do this, create a property with this statement:
            <acess modifier> ICollection<Type<model/entity>> name = new List<Type<model>>();
    c) Configure DataContext.cs:
        * create new DbSet with an type of Comment entity and a name of Comments.

        ***extra*** **WILL NOT BE IMPLEMENTING THIS ***
            by default, entity framework restricts deletion t model that has relationship due to entity framework conventions.
            but theres a way to implement this delete behavior. to do this:

            builder.Entity<modelTypeWithARelationship>()
            .hasOne(a => a.Model1WithRelationship)
            .withMany(c => c.Model2WithRelationship)
            .OnDelete(DeleteBehavior.Cascade);

        * migrate the new DbSet via:
            dotnet migrations add CommentEntityAdded --project NameOfTheProjectToBeMigrated 
            --startup-project NameOfTheStartupProjectToUse


2)  create a Data transfer object, add relationship of Activities and Comments, and modify MappingProfiles
    a)Create a new class file called CommentDto.cs with this properties:
        public int Id { get; set; }
        public DateTime CreatedAt { get; set; }
        public string Body { get; set; }
        public string Username { get; set; }
        public string DisplayName { get; set; }
        public string Image { get; set; }

    b) create a new map with generic type of Comment and CommentDto, then add the .ForMemeber for each individual 
        CommentDto property.
        example:

        .ForMember(d => d.DisplayName, o => o.MapFrom(s => s.Author.DisplayName))

        .ForMember is the method for customizing each individual member,
        d => d.DisplayName is the destination from the CommentDto
        o => o.MapFrom is the mapp projection to link into
        s => s.Author.Displayname is the Entity/Model to link from. 

3) create a Create Handler
    a) at Application/Comment folder, create a new file called Create.cs for our new handler.
    b) at the Create.cs, create a new class Command with an interface of IRequest with generic type of <Result<CommentDto>>
    c) dont forget to import necessary namespaces (
        using Application.Core;
        using Mediatr;
    )
    d)  need to receive two properties which is a string for the body of the comment, and the Guid of ActivityId where 
    the comment is going to be the part of that Activities collection of comments.
    
    e) in the same Create class handler, add a new class for CommandValidator so we can restrict having an empty comment.
    you can do this by:

        public class CommandValidator : AbstractValidator<Command>

        then import the fluentValidation namespace

        the rules are:

        RuleFor(x => x.Body).NotEmpty();

    f) in the same create class handler, create a class handler with an interface of IRequestHandler with generic type
    of <Command, Result<CommentDto>>. Then add the interface for IRequestHandler by Ctrl+. 

    g) generate a constructor, or simply hardcode the constructor for the Handler class. then inside the constructor's 
    parenthesis, define your parameters, namely, DataContext context, IMapper mapper, IUserAccessor userAccessor. these
    are needed to: first, access the database context, then, shape the data using the mapping profile configurations, 
    last, to access the current user.

    f) initialize all field from parameters


4) create a list comment

5) add SignalR to the client


